#!/usr/bin/env python
# vim:fileencoding=utf-8

import rospy
from geometry_msgs.msg import *
from std_msgs.msg import *
import tf
import math
from std_srvs.srv import Trigger
from fulanghua_srvs.srv import Pose

class GoalManager:
    def __init__(self, nav_publisher, world_frame, robot_frame):
        self.nav_publisher = nav_publisher
        self.tf_listener = tf.TransformListener()

        self.goal_pose = geometry_msgs.msg.Pose

        self.world_frame = world_frame
        self.robot_frame = robot_frame

    def set_goal(self, goal_pose):
        self.goal_pose = goal_pose

    def get_goal(self):
        return self.goal_pose

    def start_nav(self):
        self.nav_publisher.publish(self.goal_pose)

    def is_arrive_goal(self,dist_thr=1.0):
        try:
            (trans, rot) = self.tf_listener.lookupTransform(self.world_frame, self.robot_frame, rospy.Time(0))
            x = trans[0]
            y = trans[1]

            dist = math.sqrt(math.pow(x - self.goal_pose.pose.position.x, 2) + math.pow(y - self.goal_pose.pose.position.y, 2))

        except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
            return False

        if dist < dist_thr:
            return True
        else:
            return False

class TsukubaChallengeStrategy:
    def __init__(self):
        rospy.init_node('tsukuba_challenge_strategy')
        self.start_nav_server = rospy.Service('start_nav', Trigger, self.start_nav_callback)
        self.resume_nav_server = rospy.Service('resume_nav', Trigger, self.resume_nav_callback)

        rospy.Subscriber('/target_point', PointStamped, self.target_position_cb, queue_size=10)

        self.goal_pose_pub = rospy.Publisher('/move_base_simple/goal', PoseStamped, queue_size=10)

        suspend_pose_cfg = rospy.get_param('~suspend_pose')
        resume_pose_cfg = rospy.get_param('~resume_pose')
        self.world_frame = rospy.get_param('~world_frame', 'map')
        self.robot_frame = rospy.get_param('~robot_frame', 'base_link')
        self.target_position = geometry_msgs.msg.PoseStamped()
        self.is_search = rospy.get_param('~is_search', True)
        self.search_rect = rospy.get_param('~search_rect',[[-1000,-1000],[1000,1000]])

        self.suspend_pose = geometry_msgs.msg.Pose()
        self.suspend_pose.position.x = suspend_pose_cfg['position']['x']
        self.suspend_pose.position.y = suspend_pose_cfg['position']['y']
        self.suspend_pose.position.z = suspend_pose_cfg['position']['z']
        self.suspend_pose.orientation.x = suspend_pose_cfg['orientation']['x']
        self.suspend_pose.orientation.y = suspend_pose_cfg['orientation']['y']
        self.suspend_pose.orientation.z = suspend_pose_cfg['orientation']['z']
        self.suspend_pose.orientation.w = suspend_pose_cfg['orientation']['w']

        self.resume_pose = geometry_msgs.msg.Pose()
        self.resume_pose.position.x = resume_pose_cfg['position']['x']
        self.resume_pose.position.y = resume_pose_cfg['position']['y']
        self.resume_pose.position.z = resume_pose_cfg['position']['z']
        self.resume_pose.orientation.x = resume_pose_cfg['orientation']['x']
        self.resume_pose.orientation.y = resume_pose_cfg['orientation']['y']
        self.resume_pose.orientation.z = resume_pose_cfg['orientation']['z']
        self.resume_pose.orientation.w = resume_pose_cfg['orientation']['w']

        self.return_pose = geometry_msgs.msg.Pose()

        print "suspend_pose = " + str(self.suspend_pose)
        print "resume_pose = " + str(self.resume_pose)

        self.tf_listener = tf.TransformListener()
        self.goal_manager = GoalManager(self.goal_pose_pub, self.world_frame, self.robot_frame)

        self.aproach_flag = False
        self.state = 'not_search'

    def target_position_cb(self, data):
        if not self.aproach_flag:
            self.target_position.header=Header(stamp=rospy.Time(0),frame_id=self.world_frame)
            self.target_position.pose.position = data.point
            self.target_position.pose.orientation = Quaternion(0.0,0.0,0.0,1.0)
            self.aproach_flag = True

    def start_nav_callback(self, req):
        try:
            rospy.loginfo("strategy: start_nav_callback")
            rospy.wait_for_service('start_wp_nav')
            start_wp_nav = rospy.ServiceProxy('start_wp_nav', Trigger)
            return start_wp_nav()
            #rospy.loginfo(start_wp_nav())
            #return (True, "successful")
        except rospy.ServiceException, e:
            print "error: %s" % e

    def resume_nav_callback(self, req):
        try:
            rospy.loginfo('strategy: resume_nav_callback')
            rospy.wait_for_service('resume_wp_pose')
            resume_wp_nav = rospy.ServiceProxy('resume_wp_pose', Pose)
            return resume_wp_nav(self.resume_pose)
        except rospy.ServiceException, e:
            print "error: %s" % e

    def get_now_pose(self):
        ident = PoseStamped(
            header=Header(
                stamp=rospy.Time(0),
                frame_id=self.robot_frame
            ),
            pose=geometry_msgs.msg.Pose()
        )
        robot_pose = PoseStamped()
        try:
            robot_pose = self.tf_listener.transformPose(self.world_frame, ident)
        except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
            rospy.loginfo('tf except')
        return robot_pose

    def is_in_search_area(self):
        now_pose = self.get_now_pose()
        x = now_pose.pose.position.x
        y = now_pose.pose.position.y

        if x > self.search_rect[0][0] and y > self.search_rect[0][1] and x < self.search_rect[1][0] and y < self.search_rect[1][1]:
            rospy.loginfo("in search_area")
            return True
        else:
            return False

    def get_distance(self, pose1, pose2):
        x1 = pose1.pose.position.x
        y1 = pose1.pose.position.y
        x2 = pose2.pose.position.x
        y2 = pose2.pose.position.y
        return math.sqrt(math.pow(x1 - x2, 2) + math.pow(y1 - y2, 2))

    def call_suspend_wp_pose(self, pose):
        rospy.wait_for_service('suspend_wp_pose')
        suspend_wp_nav = rospy.ServiceProxy('suspend_wp_pose', Pose)
        return suspend_wp_nav(Pose(pose))

    def call_resume_wp_pose(self, pose):
        rospy.wait_for_service('resume_wp_pose')
        resume_wp_nav = rospy.ServiceProxy('resume_wp_pose', Pose)
        return resume_wp_nav(Pose(pose))


    def spin(self):
        rate = rospy.Rate(10)
        self.state = 'not_search'
        state_tmp = self.state
        while not rospy.is_shutdown():
            rate.sleep()
            if self.state != state_tmp:
                rospy.loginfo(self.state)
                state_tmp = self.state
            if self.state == 'not_search':
                if self.is_search and self.is_in_search_area():
                    self.state = 'search'

            elif self.state == 'search':
                if self.aproach_flag:
                    self.state = 'approach_near_point'
                    before_dist = float('inf')

            elif self.state == 'approach_near_point':
                pose1 = self.get_now_pose()
                pose2 = self.target_position
                dist = self.get_distance(pose1, pose2)
                if dist > before_dist:
                    self.state = 'suspend_nav'
                else :
                    before_dist = dist

            elif self.state == 'suspend_nav':
                self.return_pose = self.get_now_pose()
                ret = self.call_suspend_wp_pose(self.return_pose.pose)
                if ret:
                    self.state = 'aproach_target'

            elif self.state == 'aproach_target':
                goal_pose = self.target_position
                self.goal_manager.set_goal(goal_pose)
                self.goal_manager.start_nav()
                self.state = 'wait_near_target'

            elif self.state == 'wait_near_target':
                if self.goal_manager.is_arrive_goal(dist_thr=2.0):
                    self.state = 'stop_near_target'

            elif self.state == 'stop_near_target':
                pose_arrive = self.get_now_pose()
                self.goal_manager.set_goal(pose_arrive)
                self.goal_manager.start_nav()
                self.state = 'wait_arrive_target'

            elif self.state == 'wait_arrive_target':
                if self.goal_manager.is_arrive_goal(dist_thr=0.5):
                    self.state = 'arrive_target'
                    stop_time=rospy.Time.now().to_sec()

            elif self.state == 'arrive_target':
                now = rospy.Time.now().to_sec()
                rospy.loginfo(now - stop_time)
                if now - stop_time > 5.0:
                    self.state = 'return_stop_point'

            elif self.state == 'return_stop_point':
                return_pose = self.return_pose
                self.goal_manager.set_goal(return_pose)
                self.goal_manager.start_nav()
                self.state = 'wait_resume_nav'

            elif self.state == 'wait_resume_nav':
                if self.goal_manager.is_arrive_goal(dist_thr=1.0):
                    self.state = 'resume_nav'

            elif self.state == 'resume_nav':
                self.resume_pose = self.get_now_pose()
                ret = self.call_resume_wp_pose(self.resume_pose.pose)
                if ret:
                    self.state = 'not_search'
                    self.aproach_flag= False

            '''try:
                (trans, rot) = self.tf_listener.lookupTransform(self.world_frame, self.robot_frame, rospy.Time(0))
                x = trans[0]
                y = trans[1]
                dist = math.sqrt(math.pow(x - self.suspend_pose.position.x, 2) + math.pow(y - self.suspend_pose.position.y, 2))
                #print "robot_gl = ("  + str(x) + ", " + str(y) + ")"
                #print "dist = " + str(dist)
                if(dist < 1.0) and not already_send_suspend_pose:
                    rospy.loginfo('strategy: send suspending request')
                    rospy.wait_for_service('suspend_wp_pose')
                    suspend_wp_nav = rospy.ServiceProxy('suspend_wp_pose', Pose)
                    print "suspend_wp_nav() = " + str(suspend_wp_nav(self.suspend_pose))
                    already_send_suspend_pose = True
            except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
                continue'''

if __name__ == '__main__':
    strategy = TsukubaChallengeStrategy()
    strategy.spin()
